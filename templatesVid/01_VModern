const { createCanvas, loadImage /*, registerFont*/ } = require('canvas');
const GIFEncoder = require('gif-encoder-2');
const fs = require('fs');

/*
// Falls du Open Sans lokal einbinden willst:
registerFont('/path/to/OpenSans-ExtraBold.ttf', { family: 'Open Sans', weight: '900' });
registerFont('/path/to/OpenSans-Bold.ttf',      { family: 'Open Sans', weight: '700' });
*/

module.exports = async function generateTemplateGIF(opts = {}) {
  const {
    sourceImage,
    overlayText,
    website = "www.montessori-helden.de",
    width = 1000,           // Pinterest-Format: 1000 px breit
    height = 1500,          // Pinterest-Format: 1500 px hoch
    fps = 24,
    durationSec = 3.0,
    outputPath = './out.gif',
    background = '#ffffff',
    boxColor = 'rgba(42, 37, 26, 0.9)', // aus Videoanalyse
  } = opts;

  const totalFrames = Math.max(1, Math.round(fps * durationSec));
  const encoder = new GIFEncoder(width, height, 'neuquant', true);
  encoder.start();
  encoder.setDelay(Math.round(1000 / fps));
  encoder.setRepeat(0);
  encoder.setQuality(10);

  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');
  const img = await loadImage(sourceImage);

  // === Hilfsfunktionen ===
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function breakLongWord(ctx, word, maxWidth) {
    let parts = [], current = '';
    for (let char of word) {
      const test = current + char;
      if (ctx.measureText(test).width > maxWidth) {
        if (current.length > 0) {
          parts.push(current + '-');
          current = char;
        } else {
          parts.push(char);
          current = '';
        }
      } else {
        current = test;
      }
    }
    if (current.length > 0) parts.push(current);
    return parts;
  }

  function wrapText(ctx, text, maxWidth, maxLines) {
    const words = text.split(' ');
    let lines = [], currentLine = '';

    for (let word of words) {
      if (ctx.measureText(word).width > maxWidth) {
        const broken = breakLongWord(ctx, word, maxWidth);
        for (let part of broken) {
          if (currentLine.length > 0) {
            lines.push(currentLine);
            currentLine = '';
          }
          lines.push(part);
          if (lines.length === maxLines) return lines;
        }
        continue;
      }
      const testLine = currentLine ? currentLine + ' ' + word : word;
      if (ctx.measureText(testLine).width <= maxWidth) {
        currentLine = testLine;
      } else {
        lines.push(currentLine);
        currentLine = word;
        if (lines.length === maxLines) return lines;
      }
    }
    if (currentLine && lines.length < maxLines) lines.push(currentLine);
    return lines;
  }

  function drawVignette(ctx, width, height, strength = 0.35) {
    const vignette = ctx.createRadialGradient(
      width / 2, height / 2, Math.min(width, height) * 0.35,
      width / 2, height / 2, Math.max(width, height) * 0.5
    );
    vignette.addColorStop(0, 'rgba(0,0,0,0)');
    vignette.addColorStop(1, `rgba(0,0,0,${strength})`);
    ctx.save();
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, width, height);
    ctx.restore();

    const corners = [
      { x: 0, y: 0 }, { x: width, y: 0 },
      { x: 0, y: height }, { x: width, y: height }
    ];
    const radius = Math.min(width, height) * 0.35;

    for (const corner of corners) {
      const grad = ctx.createRadialGradient(corner.x, corner.y, 0, corner.x, corner.y, radius);
      grad.addColorStop(0, 'rgba(0,0,0,0.18)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.save();
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(corner.x, corner.y, radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.restore();
    }
  }

  // === Textlayout ===
  function measureTextLayout(ctx, overlayText, width, height) {
    const padding = 20;
    const maxTextWidth = width * 0.8;
    const maxTextBlockHeight = height * 0.25;
    const maxLines = 2;

    let chosenFontSize = 16;
    let lines = [];
    let lineHeight = 0;

    for (let size = 128; size >= 16; size -= 2) {
      ctx.font = `900 ${size}px "Open Sans"`;
      lineHeight = size * 1.3;
      const testLines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
      const totalTextHeight = testLines.length * lineHeight;
      const joined = testLines.join('').replace(/-/g, '').replace(/\s/g, '');
      const original = overlayText.replace(/-/g, '').replace(/\s/g, '');
      if (testLines.length <= maxLines &&
          totalTextHeight <= maxTextBlockHeight &&
          joined === original) {
        chosenFontSize = size;
        lines = testLines;
        break;
      }
    }
    if (lines.length === 0) {
      ctx.font = `900 16px "Open Sans"`;
      lineHeight = 16 * 1.3;
      lines = wrapText(ctx, overlayText, maxTextWidth, maxLines);
    }

    const urlFontSize = 48;
    const urlLineHeight = urlFontSize * 1.3;

    ctx.font = `900 ${chosenFontSize}px "Open Sans"`;
    const totalTextHeight = lines.length * lineHeight;
    const urlPaddingTop = padding * 0.6;

    const rectWidth = maxTextWidth + padding * 2;
    const rectHeight = totalTextHeight + padding * 2 + urlLineHeight + urlPaddingTop;

    const verticalPositionFactor = 0.8;
    let rectY = height * verticalPositionFactor - rectHeight / 2;
    rectY -= 910; // aus deinem Originalcode
    const rectX = (width - rectWidth) / 2;

    return {
      padding,
      lines,
      lineHeight,
      urlFontSize,
      totalTextHeight,
      urlPaddingTop,
      rectWidth,
      rectHeight,
      rectX,
      rectY,
    };
  }

  const layout = measureTextLayout(ctx, overlayText || '', width, height);

  // === Easing ===
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  const easeInOut = t => t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;

  // === Animation Frames ===
  for (let frame = 0; frame < totalFrames; frame++) {
    const t = frame / (totalFrames - 1 || 1);
    const zoom = 1.03 + 0.02 * easeOutCubic(t);
    const vignetteStrength = 0.28 + 0.07 * Math.sin(t * Math.PI);
    const boxAlpha = easeInOut(Math.min(1, t * 1.4));

    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, width, height);

    // Bild contain + zentrieren
    const imgRatio = img.width / img.height;
    const canvasRatio = width / height;
    let drawW, drawH;
    if (imgRatio > canvasRatio) {
      drawH = height * zoom;
      drawW = drawH * imgRatio;
    } else {
      drawW = width * zoom;
      drawH = drawW / imgRatio;
    }
    const dx = (width - drawW) / 2;
    const dy = (height - drawH) / 2;
    ctx.drawImage(img, dx, dy, drawW, drawH);

    drawVignette(ctx, width, height, vignetteStrength);

    const { padding, lines, lineHeight, urlFontSize, totalTextHeight,
            urlPaddingTop, rectWidth, rectHeight, rectX, rectY } = layout;

    // Box
    ctx.save();
    ctx.globalAlpha = boxAlpha;
    ctx.shadowColor = 'rgba(0,0,0,0.08)';
    ctx.shadowBlur = 8;
    roundRect(ctx, rectX, rectY, rectWidth, rectHeight, 36);
    ctx.fillStyle = boxColor;
    ctx.fill();
    ctx.restore();

    // Haupttext
    ctx.save();
    ctx.globalAlpha = boxAlpha;
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const fontSize = Math.round(lineHeight / 1.3);
    ctx.font = `900 ${fontSize}px "Open Sans"`;
    lines.forEach((line, index) => {
      const y = rectY + padding + index * lineHeight;
      ctx.fillText(line, width / 2, y);
    });
    ctx.restore();

    // URL
    ctx.save();
    ctx.globalAlpha = boxAlpha;
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${urlFontSize}px "Open Sans"`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(website, width / 2, rectY + padding + totalTextHeight + urlPaddingTop);
    ctx.restore();

    encoder.addFrame(ctx);
  }

  encoder.finish();
  fs.writeFileSync(outputPath, encoder.out.getData());
  return outputPath;
};
